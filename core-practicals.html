<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Core Practicals - Chemistry Tools</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
    <!-- SheetJS for reading Excel files -->
    <script src="xlsx.full.min.js"></script>
    <!-- jsPDF for PDF generation -->
    <!-- Note: Consider adding integrity hashes for production use to ensure library integrity -->
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf-autotable@3.5.31/dist/jspdf.plugin.autotable.min.js"></script>
    <!-- JSZip for creating ZIP files -->
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <!-- FileSaver for downloading files -->
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <style>
        .header-container {
            position: relative;
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }
        .home-button {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            font-size: 2rem;
            text-decoration: none;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            margin: 0;
        }
        .home-button:hover {
            opacity: 0.7;
        }
        .page-title {
            flex: 1;
            text-align: center;
            margin: 0;
        }
        .table-wrapper {
            overflow-x: auto;
            margin-top: 20px;
        }
        .cell-y {
            background-color: #90ee90 !important;
            text-align: center;
        }
        .cell-wt {
            background-color: #ffc107 !important;
            text-align: center;
        }
        .cell-n {
            background-color: #dc3545 !important;
            text-align: center;
        }
        .cell-blank {
            text-align: center;
        }
        .filter-section {
            margin-bottom: 20px;
        }
        table {
            white-space: nowrap;
        }
        th {
            position: sticky;
            top: 0;
            background-color: white;
            z-index: 10;
        }
        .cp-badge {
            display: inline-block;
            background-color: #0d6efd;
            color: white;
            padding: 4px 12px;
            margin: 2px;
            border-radius: 16px;
            font-size: 0.875rem;
        }
        .cp-badge-y {
            background-color: #28a745;
            color: white;
        }
        .cp-badge-wt {
            background-color: #ffc107;
            color: black;
        }
        .cp-badge-n {
            background-color: #dc3545;
            color: white;
        }
        .cp-badge-blank {
            background-color: white;
            color: black;
            border: 1px solid #dee2e6;
        }
        .student-name-link {
            cursor: pointer;
            color: #0d6efd;
            text-decoration: underline;
        }
        .student-name-link:hover {
            color: #0a58ca;
        }
        #studentView {
            display: none;
        }
        #studentViewHeading {
            margin-top: 20px;
            margin-bottom: 20px;
        }
        .export-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-4">
        <div class="row">
            <div class="col-12">
                <div class="header-container">
                    <a href="index.html" class="home-button" title="Home">üè†</a>
                    <h1 class="page-title">Core Practicals</h1>
                </div>
            </div>
        </div>

        <!-- File Upload Section -->
        <div class="row">
            <div class="col-12">
                <div class="card mb-4">
                    <div class="card-body">
                        <h5 class="card-title">Upload Spreadsheet</h5>
                        <input type="file" id="fileInput" class="form-control" accept=".xlsx,.xls">
                        <small class="form-text text-muted">Upload an Excel file (.xlsx or .xls) with student core practical data</small>
                    </div>
                </div>
            </div>
        </div>

        <!-- Filter Section -->
        <div class="row filter-section" id="filterSection" style="display: none;">
            <div class="col-md-2">
                <label for="year12Filter" class="form-label">Year 12 Class:</label>
                <select id="year12Filter" class="form-select">
                    <option value="">All Classes</option>
                </select>
            </div>
            <div class="col-md-2">
                <label for="year13Filter" class="form-label">Year 13 Class:</label>
                <select id="year13Filter" class="form-select">
                    <option value="">All Classes</option>
                </select>
            </div>
            <div class="col-md-2">
                <label for="studentFilter" class="form-label">Student:</label>
                <select id="studentFilter" class="form-select">
                    <option value="">All Students</option>
                </select>
            </div>
            <div class="col-md-2">
                <label for="assignmentFilter" class="form-label">CPAC:</label>
                <select id="assignmentFilter" class="form-select">
                    <option value="">All CPACs</option>
                </select>
            </div>
            <div class="col-md-2">
                <label for="labelFilter" class="form-label">CP:</label>
                <select id="labelFilter" class="form-select">
                    <option value="">All CPs</option>
                </select>
            </div>
        </div>

        <!-- Data Table Section -->
        <div class="row">
            <div class="col-12">
                <!-- Grid View -->
                <div class="table-wrapper" id="gridView">
                    <table id="dataTable" class="table table-bordered table-hover" style="display: none;">
                        <thead id="tableHead"></thead>
                        <tbody id="tableBody"></tbody>
                    </table>
                    <div class="export-buttons" id="classExportButtons" style="display: none;">
                        <button id="exportCombinedBtn" class="btn btn-primary">Export Combined PDF</button>
                        <button id="exportSeparateBtn" class="btn btn-primary">Export Separate PDFs (ZIP)</button>
                    </div>
                </div>
                <!-- Student View -->
                <div id="studentView">
                    <h2 id="studentViewHeading"></h2>
                    <div class="table-wrapper">
                        <table id="studentTable" class="table table-bordered">
                            <thead>
                                <tr>
                                    <th>CPAC</th>
                                    <th>CPs</th>
                                </tr>
                            </thead>
                            <tbody id="studentTableBody"></tbody>
                        </table>
                    </div>
                    <div class="export-buttons">
                        <button id="exportStudentBtn" class="btn btn-primary">Export PDF</button>
                        <button id="backToGridBtn" class="btn btn-secondary">Back to Grid View</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>

    <script>
        let rawData = [];
        let header1 = []; // First header row (assignments like 1a, 2a, etc.)
        let header2 = []; // Second header row (labels like CP1, CP2, etc.)

        document.getElementById('fileInput').addEventListener('change', handleFile);

        const cpacDescriptions = {
            "CPAC 1": "Follows written procedures\n(a) Correctly follows instructions to carry out the experimental techniques or procedures.",
            "CPAC 2": "Applies investigative approaches and methods when using instruments and equipment\n(a) Correctly uses appropriate instrumentation, apparatus and materials (including ICT) to carry out investigative activities, experimental techniques and procedures with minimal assistance or prompting.\n(b) Carries out techniques or procedures methodically, in sequence and in combination, identifying practical issues and making adjustments when necessary.\n(c) Identifies and controls significant quantitative variables where applicable, and plans approaches to take account of variables that cannot readily be controlled.\n(d) Selects appropriate equipment and measurement strategies in order to ensure suitably accurate results.",
            "CPAC 3": "Safely uses a range of practical equipment and materials\n(a) Identifies hazards and assesses risks associated with these hazards, making safety adjustments as necessary, when carrying out experimental techniques and procedures in the lab or field.\n(b) Uses appropriate safety equipment and approaches to minimise risks with minimal prompting.",
            "CPAC 4": "Makes and records observations\n(a) Makes accurate observations relevant to the experimental or investigative procedure.\n(b) Obtains accurate, precise and sufficient data for experimental and investigative procedures and records this methodically using appropriate units and conventions.",
            "CPAC 5": "Researches, references and reports\n(a) Uses appropriate software and/or tools to process data, carry out research and report findings.\n(b) Sources of information are cited demonstrating that research has taken place, supporting planning and conclusions."
        };

        function handleFile(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet, {header: 1, defval: '0'});
                    
                    if (jsonData.length < 3) {
                        alert('File must contain at least 2 header rows and 1 data row');
                        return;
                    }

                    // Parse headers and data
                    header1 = jsonData[0];
                    header2 = jsonData[1];
                    
                    // Filter out completely blank rows (all values are empty, undefined, or "0")
                    rawData = jsonData.slice(2).filter(row => {
                        // Check if row has any non-blank, non-zero value
                        return row.some(cell => cell && cell !== '0' && cell !== '');
                    });

                    populateFilters();
                    renderTable();
                    
                    document.getElementById('filterSection').style.display = 'flex';
                    document.getElementById('dataTable').style.display = 'table';
                } catch (error) {
                    alert('Error reading file: ' + error.message);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function populateFilters() {
            // Populate Year 12 and Year 13 class filters
            const year12Classes = new Set();
            const year13Classes = new Set();
            const assignments = new Set();
            const labels = new Set();
            const students = new Set();

            rawData.forEach(row => {
                if (row[1] && row[1] !== '0') year12Classes.add(row[1]);
                if (row[2] && row[2] !== '0') year13Classes.add(row[2]);
                if (row[0] && row[0] !== '0') students.add(row[0]);
            });

            // Populate assignment and label filters from headers
            for (let i = 3; i < header1.length; i++) {
                if (header1[i] && header1[i] !== '0') assignments.add(header1[i]);
                if (header2[i] && header2[i] !== '0') labels.add(header2[i]);
            }

            populateSelect('year12Filter', Array.from(year12Classes).sort());
            populateSelect('year13Filter', Array.from(year13Classes).sort());
            populateSelect('studentFilter', Array.from(students).sort());
            populateSelect('assignmentFilter', Array.from(assignments).sort());
            populateSelect('labelFilter', Array.from(labels).sort());

            // Add event listeners for filters
            document.getElementById('year12Filter').addEventListener('change', handleClassFilterChange);
            document.getElementById('year13Filter').addEventListener('change', handleClassFilterChange);
            document.getElementById('studentFilter').addEventListener('change', handleStudentFilterChange);
            document.getElementById('assignmentFilter').addEventListener('change', renderTable);
            document.getElementById('labelFilter').addEventListener('change', renderTable);
            document.getElementById('backToGridBtn').addEventListener('click', backToGridView);
            document.getElementById('exportStudentBtn').addEventListener('click', exportStudentPDF);
            document.getElementById('exportCombinedBtn').addEventListener('click', exportCombinedPDF);
            document.getElementById('exportSeparateBtn').addEventListener('click', exportSeparatePDFs);
        }

        function handleClassFilterChange() {
            // Clear student selection when class filter changes
            document.getElementById('studentFilter').value = '';
            renderTable();
        }

        function populateSelect(selectId, options) {
            const select = document.getElementById(selectId);
            const firstOptionText = select.options[0].text;
            // Keep the first "All" option
            select.innerHTML = '<option value="">' + firstOptionText + '</option>';
            options.forEach(option => {
                const opt = document.createElement('option');
                opt.value = option;
                opt.textContent = option;
                select.appendChild(opt);
            });
        }

        function renderTable() {
            const year12Filter = document.getElementById('year12Filter').value;
            const year13Filter = document.getElementById('year13Filter').value;
            const assignmentFilter = document.getElementById('assignmentFilter').value;
            const labelFilter = document.getElementById('labelFilter').value;
            const studentFilter = document.getElementById('studentFilter').value;

            // If a student is selected, show student view
            if (studentFilter) {
                renderStudentView(studentFilter);
                return;
            }

            // Show grid view
            document.getElementById('gridView').style.display = 'block';
            document.getElementById('studentView').style.display = 'none';

            // Filter rows by Year 12 and Year 13 classes
            let filteredData = rawData.filter(row => {
                const year12Match = !year12Filter || row[1] === year12Filter;
                const year13Match = !year13Filter || row[2] === year13Filter;
                return year12Match && year13Match;
            });

            // Filter columns by assignment and label
            let visibleColumns = [0, 1, 2]; // Always show Surname, Year 12 Set, Year 13 Set
            for (let i = 3; i < header1.length; i++) {
                const assignmentMatch = !assignmentFilter || header1[i] === assignmentFilter;
                const labelMatch = !labelFilter || header2[i] === labelFilter;
                if (assignmentMatch && labelMatch) {
                    visibleColumns.push(i);
                }
            }

            // Render table headers
            const thead = document.getElementById('tableHead');
            thead.innerHTML = '';
            
            // First header row (assignments)
            const headerRow1 = document.createElement('tr');
            visibleColumns.forEach(colIndex => {
                const th = document.createElement('th');
                const headerValue = header1[colIndex];
                th.textContent = (headerValue && headerValue !== '0') ? headerValue : '';
                headerRow1.appendChild(th);
            });
            thead.appendChild(headerRow1);

            // Second header row (labels)
            const headerRow2 = document.createElement('tr');
            visibleColumns.forEach(colIndex => {
                const th = document.createElement('th');
                const headerValue = header2[colIndex];
                th.textContent = (headerValue && headerValue !== '0') ? headerValue : '';
                headerRow2.appendChild(th);
            });
            thead.appendChild(headerRow2);

            // Render table body
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';
            
            filteredData.forEach(row => {
                const tr = document.createElement('tr');
                visibleColumns.forEach(colIndex => {
                    const td = document.createElement('td');
                    const cellValue = row[colIndex] || '0';
                    
                    // Apply styling based on cell value
                    if (colIndex > 2) { // Only for data columns, not name/class columns
                        if (cellValue === 'y') {
                            td.className = 'cell-y';
                            td.textContent = 'y';
                        } else if (cellValue === 'wt') {
                            td.className = 'cell-wt';
                            td.textContent = 'wt';
                        } else if (cellValue === 'n') {
                            td.className = 'cell-n';
                            td.textContent = 'n';
                        } else {
                            td.className = 'cell-blank';
                            td.textContent = '';
                        }
                    } else if (colIndex === 0) {
                        // Make student name a clickable link
                        const studentName = cellValue === '0' ? '' : cellValue;
                        const span = document.createElement('span');
                        span.className = 'student-name-link';
                        span.textContent = studentName;
                        span.addEventListener('click', () => showStudentView(studentName));
                        td.appendChild(span);
                    } else {
                        td.textContent = cellValue === '0' ? '' : cellValue;
                    }
                    
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            
            document.getElementById('dataTable').style.display = 'table';
            
            // Show class export buttons if there are students in the filtered view
            const classExportButtons = document.getElementById('classExportButtons');
            if (filteredData.length > 0) {
                classExportButtons.style.display = 'flex';
            } else {
                classExportButtons.style.display = 'none';
            }
        }

        function handleStudentFilterChange() {
            renderTable();
        }

        function showStudentView(studentName) {
            document.getElementById('studentFilter').value = studentName;
            renderStudentView(studentName);
        }

        function renderStudentView(studentName) {
            // Hide grid view, show student view
            document.getElementById('gridView').style.display = 'none';
            document.getElementById('studentView').style.display = 'block';
            
            // Set student name as heading
            document.getElementById('studentViewHeading').textContent = studentName;
            
            const assignmentFilter = document.getElementById('assignmentFilter').value;
            const labelFilter = document.getElementById('labelFilter').value;
            
            // Find the student's row
            const studentRow = rawData.find(row => row[0] === studentName);
            if (!studentRow) {
                document.getElementById('studentTableBody').innerHTML = '<tr><td colspan="2">Student not found</td></tr>';
                return;
            }
            
            // Build a map of CPAC -> CPs with their statuses
            const cpacMap = new Map();
            
            for (let i = 3; i < header1.length; i++) {
                const cpac = header1[i];
                const cp = header2[i];
                const value = studentRow[i];
                
                // Apply filters
                const assignmentMatch = !assignmentFilter || cpac === assignmentFilter;
                const labelMatch = !labelFilter || cp === labelFilter;
                
                if (assignmentMatch && labelMatch && cpac && cpac !== '0' && cp && cp !== '0') {
                    if (!cpacMap.has(cpac)) {
                        cpacMap.set(cpac, []);
                    }
                    // Store CP with its status (y, wt, n, or blank)
                    const status = getCpStatusFromValue(value);
                    cpacMap.get(cpac).push({ cp: cp, status: status });
                }
            }
            
            // Sort CPACs
            const sortedCpacs = Array.from(cpacMap.keys()).sort();
            
            // Render student table
            const tbody = document.getElementById('studentTableBody');
            tbody.innerHTML = '';
            
            sortedCpacs.forEach(cpac => {
                const tr = document.createElement('tr');
                
                const cpacCell = document.createElement('td');
                cpacCell.textContent = cpac;
                tr.appendChild(cpacCell);
                
                const cpsCell = document.createElement('td');
                const cpData = cpacMap.get(cpac) || [];
                cpData.forEach(({ cp, status }) => {
                    const badge = document.createElement('span');
                    badge.className = `cp-badge cp-badge-${status || 'blank'}`;
                    badge.textContent = cp;
                    cpsCell.appendChild(badge);
                });
                tr.appendChild(cpsCell);
                
                tbody.appendChild(tr);
            });
        }

        function backToGridView() {
            document.getElementById('studentFilter').value = '';
            renderTable();
        }

        // PDF Export Functions
        function sanitizeFilename(name) {
            return name.replace(/[^a-zA-Z0-9]/g, '_');
        }

        const VALID_CP_STATUSES = new Set(['y', 'wt', 'n']);

        function getCpStatusFromValue(value) {
            // Return status if it's y, wt, or n, otherwise return empty string
            return VALID_CP_STATUSES.has(value) ? value : '';
        }

        function formatCpWithStatus(cp, status) {
            // Format CP name with status indicator for PDF export
            if (status === 'y') return `${cp} (‚úì)`;
            if (status === 'wt') return `${cp} (WT)`;
            if (status === 'n') return `${cp} (‚úó)`;
            return cp;
        }

        function getStudentData(studentName) {
            const assignmentFilter = document.getElementById('assignmentFilter').value;
            const labelFilter = document.getElementById('labelFilter').value;
            
            const studentRow = rawData.find(row => row[0] === studentName);
            if (!studentRow) return null;
            
            const cpacMap = new Map();
            
            for (let i = 3; i < header1.length; i++) {
                const cpac = header1[i];
                const cp = header2[i];
                const value = studentRow[i];
                
                const assignmentMatch = !assignmentFilter || cpac === assignmentFilter;
                const labelMatch = !labelFilter || cp === labelFilter;
                
                if (assignmentMatch && labelMatch && cpac && cpac !== '0' && cp && cp !== '0') {
                    if (!cpacMap.has(cpac)) {
                        cpacMap.set(cpac, []);
                    }
                    // Store CP with its status (y, wt, n, or blank)
                    const status = getCpStatusFromValue(value);
                    cpacMap.get(cpac).push({ cp: cp, status: status });
                }
            }
            
            return {
                cpacMap: cpacMap,
                allCpacs: Array.from(cpacMap.keys()).sort()
            };
        }

        function getColorForStatus(status) {
            // Return RGB color arrays matching the HTML view colors
            if (status === 'y') return [40, 167, 69];      // Green (#28a745)
            if (status === 'wt') return [255, 193, 7];     // Yellow (#ffc107)
            if (status === 'n') return [220, 53, 69];      // Red (#dc3545)
            return [255, 255, 255];                         // White for blank
        }

        function getTextColorForStatus(status) {
            // Return text color (black or white) for readability
            if (status === 'wt' || !status) return [0, 0, 0];  // Black text for yellow and white backgrounds
            return [255, 255, 255];                              // White text for green and red backgrounds
        }

        function generateStudentPDF(studentName) {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            const studentData = getStudentData(studentName);
            if (!studentData) {
                alert('Student data not found');
                return null;
            }
            
            // Add title
            doc.setFontSize(18);
            doc.text(studentName, 14, 20);
            
            // Create table data with CP objects for custom rendering
            const tableData = [];
            studentData.allCpacs.forEach(cpac => {
                const cpData = studentData.cpacMap.get(cpac) || [];
                const description = cpacDescriptions['CPAC ' + cpac.charAt(0)] || '';
                tableData.push([cpac, cpData, description]);
            });
            
            // Add table with custom cell rendering for colored badges
            doc.autoTable({
                startY: 30,
                head: [['CPAC', 'CPs', 'Description']],
                body: tableData,
                theme: 'grid',
                headStyles: { fillColor: [13, 110, 253] },
                styles: { cellPadding: 2, fontSize: 10 },
                columnStyles: {
                    0: { cellWidth: 20 },
                    1: { cellWidth: 60 },
                    2: { cellWidth: 'auto', fontSize: 7 }
                },
                didDrawCell: function(data) {
                    // Custom rendering for CP badges in the second column
                    if (data.column.index === 1 && data.section === 'body') {
                        const cpData = data.cell.raw;
                        if (Array.isArray(cpData) && cpData.length > 0) {
                            const cell = data.cell;
                            const cellX = cell.x;
                            const cellY = cell.y;
                            const cellPadding = 3;
                            
                            let xOffset = cellX + cellPadding;
                            const yOffset = cellY + cellPadding;
                            const badgeHeight = 6;
                            const badgePadding = 2;
                            const badgeMargin = 2;
                            
                            cpData.forEach(({ cp, status }) => {
                                // Measure text width
                                doc.setFontSize(9);
                                const textWidth = doc.getTextWidth(cp);
                                const badgeWidth = textWidth + (badgePadding * 2);
                                
                                // Check if badge fits in current line, if not wrap to next line
                                if (xOffset + badgeWidth > cell.x + cell.width - cellPadding) {
                                    xOffset = cellX + cellPadding;
                                }
                                
                                // Draw badge background with rounded corners
                                const bgColor = getColorForStatus(status);
                                doc.setFillColor(bgColor[0], bgColor[1], bgColor[2]);
                                
                                // Draw rounded rectangle for badge
                                const radius = 2;
                                doc.roundedRect(xOffset, yOffset, badgeWidth, badgeHeight, radius, radius, 'F');
                                
                                // Draw border for blank badges
                                if (!status) {
                                    doc.setDrawColor(222, 226, 230);  // Light gray border (#dee2e6)
                                    doc.setLineWidth(0.2);
                                    doc.roundedRect(xOffset, yOffset, badgeWidth, badgeHeight, radius, radius, 'S');
                                }
                                
                                // Draw text
                                const textColor = getTextColorForStatus(status);
                                doc.setTextColor(textColor[0], textColor[1], textColor[2]);
                                doc.text(cp, xOffset + badgePadding, yOffset + badgeHeight - 1.5);
                                
                                xOffset += badgeWidth + badgeMargin;
                            });
                            
                            // Reset colors
                            doc.setTextColor(0, 0, 0);
                            doc.setDrawColor(0, 0, 0);
                        }
                    }
                },
                willDrawCell: function(data) {
                    // Clear default text rendering for CP column
                    if (data.column.index === 1 && data.section === 'body') {
                        data.cell.text = '';
                    }
                }
            });
            
            return doc;
        }

        function exportStudentPDF() {
            const studentName = document.getElementById('studentViewHeading').textContent;
            const doc = generateStudentPDF(studentName);
            if (doc) {
                const filename = `${sanitizeFilename(studentName)}_CorePracticals.pdf`;
                doc.save(filename);
            }
        }

        function getFilteredStudents() {
            const year12Filter = document.getElementById('year12Filter').value;
            const year13Filter = document.getElementById('year13Filter').value;
            
            return rawData.filter(row => {
                const year12Match = !year12Filter || row[1] === year12Filter;
                const year13Match = !year13Filter || row[2] === year13Filter;
                return year12Match && year13Match;
            }).map(row => row[0]).filter(name => name && name !== '0');
        }

        function exportCombinedPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            const students = getFilteredStudents();
            if (students.length === 0) {
                alert('No students to export');
                return;
            }
            
            students.forEach((studentName, index) => {
                if (index > 0) {
                    doc.addPage();
                }
                
                const studentData = getStudentData(studentName);
                if (!studentData) return;
                
                // Add title
                doc.setFontSize(18);
                doc.text(studentName, 14, 20);
                
                // Create table data with CP objects for custom rendering
                const tableData = [];
                studentData.allCpacs.forEach(cpac => {
                    const cpData = studentData.cpacMap.get(cpac) || [];
                    const description = cpacDescriptions['CPAC ' + cpac.charAt(0)] || '';
                    tableData.push([cpac, cpData, description]);
                });
                
                // Add table with custom cell rendering for colored badges
                doc.autoTable({
                    startY: 30,
                    head: [['CPAC', 'CPs', 'Description']],
                    body: tableData,
                    theme: 'grid',
                    headStyles: { fillColor: [13, 110, 253] },
                    styles: { cellPadding: 2, fontSize: 10 },
                    columnStyles: {
                        0: { cellWidth: 20 },
                        1: { cellWidth: 60 },
                        2: { cellWidth: 'auto', fontSize: 7 }
                    },
                    didDrawCell: function(data) {
                        // Custom rendering for CP badges in the second column
                        if (data.column.index === 1 && data.section === 'body') {
                            const cpData = data.cell.raw;
                            if (Array.isArray(cpData) && cpData.length > 0) {
                                const cell = data.cell;
                                const cellX = cell.x;
                                const cellY = cell.y;
                                const cellPadding = 3;
                                
                                let xOffset = cellX + cellPadding;
                                const yOffset = cellY + cellPadding;
                                const badgeHeight = 6;
                                const badgePadding = 2;
                                const badgeMargin = 2;
                                
                                cpData.forEach(({ cp, status }) => {
                                    // Measure text width
                                    doc.setFontSize(9);
                                    const textWidth = doc.getTextWidth(cp);
                                    const badgeWidth = textWidth + (badgePadding * 2);
                                    
                                    // Check if badge fits in current line, if not wrap to next line
                                    if (xOffset + badgeWidth > cell.x + cell.width - cellPadding) {
                                        xOffset = cellX + cellPadding;
                                    }
                                    
                                    // Draw badge background with rounded corners
                                    const bgColor = getColorForStatus(status);
                                    doc.setFillColor(bgColor[0], bgColor[1], bgColor[2]);
                                    
                                    // Draw rounded rectangle for badge
                                    const radius = 2;
                                    doc.roundedRect(xOffset, yOffset, badgeWidth, badgeHeight, radius, radius, 'F');
                                    
                                    // Draw border for blank badges
                                    if (!status) {
                                        doc.setDrawColor(222, 226, 230);  // Light gray border (#dee2e6)
                                        doc.setLineWidth(0.2);
                                        doc.roundedRect(xOffset, yOffset, badgeWidth, badgeHeight, radius, radius, 'S');
                                    }
                                    
                                    // Draw text
                                    const textColor = getTextColorForStatus(status);
                                    doc.setTextColor(textColor[0], textColor[1], textColor[2]);
                                    doc.text(cp, xOffset + badgePadding, yOffset + badgeHeight - 1.5);
                                    
                                    xOffset += badgeWidth + badgeMargin;
                                });
                                
                                // Reset colors
                                doc.setTextColor(0, 0, 0);
                                doc.setDrawColor(0, 0, 0);
                            }
                        }
                    },
                    willDrawCell: function(data) {
                        // Clear default text rendering for CP column
                        if (data.column.index === 1 && data.section === 'body') {
                            data.cell.text = '';
                        }
                    }
                });
            });
            
            doc.save('CorePracticals_Combined.pdf');
        }

        async function exportSeparatePDFs() {
            const students = getFilteredStudents();
            if (students.length === 0) {
                alert('No students to export');
                return;
            }
            
            const zip = new JSZip();
            
            // Use for...of loop with async/await for better performance with large lists
            for (const studentName of students) {
                const doc = generateStudentPDF(studentName);
                if (doc) {
                    const pdfBlob = doc.output('blob');
                    const filename = `${sanitizeFilename(studentName)}_CorePracticals.pdf`;
                    zip.file(filename, pdfBlob);
                }
            }
            
            // Generate and download the ZIP file
            const content = await zip.generateAsync({ type: 'blob' });
            saveAs(content, 'CorePracticals_All.zip');
        }
    </script>
</body>
</html>
